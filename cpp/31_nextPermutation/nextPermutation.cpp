// Source : https://leetcode-cn.com/problems/next-permutation/
// Author : Yang Li
// Date   : 2020-12-26

/********************************************************************************** 
* 题目：
* 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
* 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
* 必须 原地 修改，只允许使用额外常数空间。          
**********************************************************************************/

//感觉就是一道奥数题。。。
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int length = nums.size();
        int i = length - 2;
        while(i >= 0 && nums[i] >= nums[i + 1]) i--;
        if(i >= 0) {
            int j = length - 1;
            while(j > i && nums[j] <= nums[i]) j--;
            swap(nums[i], nums[j]);  
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};

/********************************************************************************** 
* 说明：
* 1.思路：从后向前找到第一个循序对；在a[i]以右找到大于等于a[i]的最小数，并交换两者；对a[i]以右的数做逆序操作；
* 2.逆序操作有现成的函数，直接用就行；
* 3.两次遍历和一次逆序操作，时间复杂度为o(N)；
**********************************************************************************/
